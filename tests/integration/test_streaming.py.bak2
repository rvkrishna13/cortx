"""
Integration tests for streaming functionality
"""
import pytest
from unittest.mock import AsyncMock, patch, MagicMock
from fastapi.testclient import TestClient
from src.api.main import app
from src.services.streaming import format_sse_event
from src.auth.utils import create_admin_token


@pytest.fixture
def client():
    """Create test client"""
    return TestClient(app)


@pytest.fixture
def admin_token():
    """Create admin token"""
    return create_admin_token(user_id=1, username="admin")


class TestSSEFormatting:
    """Tests for SSE event formatting"""
    
    def test_format_sse_event_start(self):
        """Test formatting start event"""
        event = format_sse_event("start", {"message": "Starting", "request_id": "123"})
        
        assert event.startswith("data: ")
        assert "start" in event
        assert "Starting" in event
        assert "123" in event
        assert event.endswith("\n\n")
    
    def test_format_sse_event_thinking(self):
        """Test formatting thinking event"""
        event = format_sse_event("thinking", {
            "step_number": 1,
            "content": "Analyzing query..."
        })
        
        assert "data: " in event
        assert "thinking" in event
        assert "step_number" in event
        assert "Analyzing query" in event
    
    def test_format_sse_event_tool_call(self):
        """Test formatting tool_call event"""
        event = format_sse_event("tool_call", {
            "step_number": 2,
            "tool_name": "query_transactions",
            "message": "Calling tool"
        })
        
        assert "data: " in event
        assert "tool_call" in event
        assert "query_transactions" in event
    
    def test_format_sse_event_tool_result(self):
        """Test formatting tool_result event"""
        event = format_sse_event("tool_result", {
            "step_number": 3,
            "tool_name": "query_transactions",
            "success": True,
            "message": "Tool completed"
        })
        
        assert "data: " in event
        assert "tool_result" in event
        assert "success" in event
    
    def test_format_sse_event_answer(self):
        """Test formatting answer event"""
        event = format_sse_event("answer", {
            "step_number": 4,
            "content": "Final answer here"
        })
        
        assert "data: " in event
        assert "answer" in event
        assert "Final answer here" in event
    
    def test_format_sse_event_done(self):
        """Test formatting done event"""
        event = format_sse_event("done", {
            "step_number": 5,
            "final_answer": "Complete",
            "tool_calls_made": 2
        })
        
        assert "data: " in event
        assert "done" in event
        assert "Complete" in event
        assert "tool_calls_made" in event


class TestStreamingEndpoint:
    """Tests for streaming endpoint behavior"""
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streaming_events_order(self, mock_orchestrator_class, mock_get_db, client, admin_token):
        """Test that streaming events are in correct order"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        
        mock_orchestrator = AsyncMock()
        events_order = []
        
        async def mock_reason(*args, **kwargs):
            events = [
                {"type": "start", "content": "Starting", "step_number": 0},
                {"type": "thinking", "content": "Step 1", "step_number": 1},
                {"type": "tool_call", "tool_name": "test_tool", "content": "Step 2", "step_number": 2},
                {"type": "tool_result", "tool_name": "test_tool", "success": True, "is_error": False, "content": "Step 3", "step_number": 3},
                {"type": "answer", "content": "Step 4", "step_number": 4},
                {"type": "done", "final_answer": "Step 5", "tool_calls_made": 1, "step_number": 5}
            ]
            for event in events:
                events_order.append(event["type"])
                yield event
        
        mock_orchestrator.reason = mock_reason
        mock_orchestrator_class.return_value = mock_orchestrator
        
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "Test query", "include_thinking": True},
            headers={"Authorization": f"Bearer {admin_token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        
        # Verify events appear in order
        start_idx = content.find("start")
        thinking_idx = content.find("thinking")
        tool_call_idx = content.find("tool_call")
        tool_result_idx = content.find("tool_result")
        answer_idx = content.find("answer")
        done_idx = content.find("done")
        
        assert start_idx < thinking_idx < tool_call_idx < tool_result_idx < answer_idx < done_idx
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streaming_headers(self, mock_orchestrator_class, mock_get_db, client, admin_token):
        """Test that streaming response has correct headers"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        
        mock_orchestrator = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "start", "content": "Starting", "step_number": 0}
            yield {"type": "done", "final_answer": "Done", "tool_calls_made": 0, "step_number": 1}
        
        mock_orchestrator.reason = mock_reason
        mock_orchestrator_class.return_value = mock_orchestrator
        
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "Test", "include_thinking": True},
            headers={"Authorization": f"Bearer {admin_token}"}
        )
        
        assert response.status_code == 200
        assert response.headers["content-type"] == "text/event-stream; charset=utf-8"
        assert "Cache-Control" in response.headers
        assert response.headers["Cache-Control"] == "no-cache"
        assert "Connection" in response.headers
        assert response.headers["Connection"] == "keep-alive"
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streaming_without_thinking(self, mock_orchestrator_class, mock_get_db, client, admin_token):
        """Test streaming without thinking steps"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        
        mock_orchestrator = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "tool_call", "tool_name": "test_tool", "content": "Calling", "step_number": 1}
            yield {"type": "tool_result", "tool_name": "test_tool", "success": True, "is_error": False, "content": "Done", "step_number": 2}
            yield {"type": "answer", "content": "Answer", "step_number": 3}
            yield {"type": "done", "final_answer": "Answer", "tool_calls_made": 1, "step_number": 4}
        
        mock_orchestrator.reason = mock_reason
        mock_orchestrator_class.return_value = mock_orchestrator
        
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "Test", "include_thinking": False},
            headers={"Authorization": f"Bearer {admin_token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "thinking" not in content or content.count("thinking") == 0  # Only start event has thinking
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streaming_multiple_tool_calls(self, mock_orchestrator_class, mock_get_db, client, admin_token):
        """Test streaming with multiple tool calls"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        
        mock_orchestrator = AsyncMock()
        async def mock_reason(*args, **kwargs):
            for i in range(3):
                yield {"type": "tool_call", "tool_name": f"tool_{i}", "content": f"Calling {i}", "step_number": i*2+1}
                yield {"type": "tool_result", "tool_name": f"tool_{i}", "success": True, "is_error": False, "content": f"Done {i}", "step_number": i*2+2}
            yield {"type": "answer", "content": "All done", "step_number": 7}
            yield {"type": "done", "final_answer": "All done", "tool_calls_made": 3, "step_number": 8}
        
        mock_orchestrator.reason = mock_reason
        mock_orchestrator_class.return_value = mock_orchestrator
        
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "Test multiple tools", "include_thinking": True},
            headers={"Authorization": f"Bearer {admin_token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert content.count("tool_call") == 3
        assert content.count("tool_result") == 3
        assert "tool_calls_made" in content
        assert "3" in content

