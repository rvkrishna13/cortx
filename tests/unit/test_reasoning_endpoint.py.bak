"""
Unit tests for reasoning endpoint
"""
import pytest
from unittest.mock import Mock, patch, AsyncMock, MagicMock
from fastapi import HTTPException
from fastapi.testclient import TestClient
from src.api.main import app
from src.utils.exceptions import ValidationError
from src.auth.utils import create_admin_token


class TestReasoningEndpointAuthorization:
    """Tests for authorization in reasoning endpoint"""
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.database.connection.database')
    def test_missing_authorization_header(self, mock_database, mock_get_db):
        """Test that missing authorization header returns 401"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_database.get_session = mock_get_db
        
        client = TestClient(app)
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test query"}
        )
        
        assert response.status_code == 401
        assert "Authorization token is required" in response.json()["detail"]
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.database.connection.database')
    @patch('src.api.routes.reasoning.get_user_from_context')
    def test_invalid_token_returns_401(self, mock_get_user, mock_database, mock_get_db):
        """Test that invalid token returns 401"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_database.get_session = mock_get_db
        mock_get_user.side_effect = ValidationError("Invalid token", field="token")
        
        client = TestClient(app)
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test query"},
            headers={"Authorization": "Bearer invalid-token"}
        )
        
        assert response.status_code == 401
        assert "Invalid or expired token" in response.json()["detail"]
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.database.connection.database')
    @patch('src.api.routes.reasoning.get_user_from_context')
    def test_valid_token_proceeds(self, mock_get_user, mock_database, mock_get_db):
        """Test that valid token allows request to proceed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_database.get_session = mock_get_db
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        with patch('src.api.routes.reasoning.MockReasoningOrchestrator') as mock_orch:
            mock_orch_instance = AsyncMock()
            async def mock_reason(*args, **kwargs):
                yield {"type": "answer", "content": "Test answer", "step_number": 1}
                yield {"type": "done", "step_number": 2}
            mock_orch_instance.reason.return_value = mock_reason()
            mock_orch.return_value = mock_orch_instance
            
            client = TestClient(app)
            token = create_admin_token(user_id=1, username="admin")
            response = client.post(
                "/api/v1/reasoning",
                json={"query": "test query"},
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 200
            assert "text/event-stream" in response.headers.get("content-type", "")


class TestReasoningEndpointOrchestratorSelection:
    """Tests for orchestrator selection logic"""
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.settings.CLAUDE_API_KEY', None)
    def test_uses_mock_orchestrator_when_no_api_key(self, mock_get_user, mock_get_db):
        """Test that mock orchestrator is used when CLAUDE_API_KEY is not set"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        with patch('src.api.routes.reasoning.MockReasoningOrchestrator') as mock_orch:
            mock_orch_instance = AsyncMock()
            async def mock_reason(*args, **kwargs):
                yield {"type": "answer", "content": "Mock answer", "step_number": 1}
                yield {"type": "done", "step_number": 2}
            mock_orch_instance.reason.return_value = mock_reason()
            mock_orch.return_value = mock_orch_instance
            
            client = TestClient(app)
            token = create_admin_token(user_id=1, username="admin")
            response = client.post(
                "/api/v1/reasoning",
                json={"query": "test"},
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 200
            mock_orch.assert_called_once()
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.settings.CLAUDE_API_KEY', 'valid-key')
    def test_uses_real_orchestrator_with_valid_key(self, mock_get_user, mock_get_db):
        """Test that real orchestrator is used when CLAUDE_API_KEY is set"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        with patch('src.api.routes.reasoning.ReasoningOrchestrator') as mock_orch:
            mock_orch_instance = AsyncMock()
            async def mock_reason(*args, **kwargs):
                yield {"type": "answer", "content": "Real answer", "step_number": 1}
                yield {"type": "done", "step_number": 2}
            mock_orch_instance.reason.return_value = mock_reason()
            mock_orch.return_value = mock_orch_instance
            
            client = TestClient(app)
            token = create_admin_token(user_id=1, username="admin")
            response = client.post(
                "/api/v1/reasoning",
                json={"query": "test"},
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 200
            mock_orch.assert_called_once()
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.settings.CLAUDE_API_KEY', 'your_claude_api_key_here')
    def test_uses_mock_orchestrator_with_placeholder_key(self, mock_get_user, mock_get_db):
        """Test that mock orchestrator is used when API key is a placeholder"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        with patch('src.api.routes.reasoning.MockReasoningOrchestrator') as mock_orch:
            mock_orch_instance = AsyncMock()
            async def mock_reason(*args, **kwargs):
                yield {"type": "answer", "content": "Mock answer", "step_number": 1}
                yield {"type": "done", "step_number": 2}
            mock_orch_instance.reason.return_value = mock_reason()
            mock_orch.return_value = mock_orch_instance
            
            client = TestClient(app)
            token = create_admin_token(user_id=1, username="admin")
            response = client.post(
                "/api/v1/reasoning",
                json={"query": "test"},
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 200
            mock_orch.assert_called_once()


class TestReasoningEndpointStreaming:
    """Tests for SSE streaming functionality"""
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_start_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that start event is streamed first"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "done", "step_number": 1}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "event: start" in content or 'type":"start' in content
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_thinking_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that thinking events are streamed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "thinking", "content": "Thinking...", "step_number": 1}
            yield {"type": "done", "step_number": 2}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test", "include_thinking": True},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "thinking" in content.lower()
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_tool_call_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that tool_call events are streamed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "tool_call", "tool_name": "query_transactions", "content": "Calling tool", "step_number": 1}
            yield {"type": "done", "step_number": 2}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "tool_call" in content.lower() or "query_transactions" in content
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_tool_result_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that tool_result events are streamed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "tool_result", "tool_name": "query_transactions", "success": True, "content": "Success", "step_number": 1}
            yield {"type": "done", "step_number": 2}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "tool_result" in content.lower()
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_answer_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that answer events are streamed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "answer", "content": "Final answer", "step_number": 1}
            yield {"type": "done", "step_number": 2}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "answer" in content.lower() or "Final answer" in content
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_error_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that error events are streamed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "error", "content": "An error occurred", "step_number": 1}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "error" in content.lower()
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_streams_done_event(self, mock_orch, mock_get_user, mock_get_db):
        """Test that done event is streamed"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            yield {"type": "done", "step_number": 1, "tool_calls_made": 0}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        content = response.text
        assert "done" in content.lower()


class TestReasoningEndpointErrorHandling:
    """Tests for error handling in reasoning endpoint"""
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    def test_handles_orchestrator_exception(self, mock_orch, mock_get_user, mock_get_db):
        """Test that orchestrator exceptions are handled"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        async def mock_reason(*args, **kwargs):
            raise Exception("Orchestrator error")
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        # Should still return 200 (SSE) but with error event
        assert response.status_code == 200
        content = response.text
        assert "error" in content.lower()
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    def test_handles_permission_error(self, mock_get_user, mock_get_db):
        """Test that permission errors return 403"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.side_effect = ValidationError("Access denied", field="permission")
        
        client = TestClient(app)
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": "Bearer token"}
        )
        
        assert response.status_code == 403 or response.status_code == 401
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    def test_handles_general_exception(self, mock_get_user, mock_get_db):
        """Test that general exceptions return 500"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        with patch('src.api.routes.reasoning.MockReasoningOrchestrator') as mock_orch:
            mock_orch.side_effect = Exception("Unexpected error")
            
            client = TestClient(app)
            token = create_admin_token(user_id=1, username="admin")
            response = client.post(
                "/api/v1/reasoning",
                json={"query": "test"},
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 500


class TestReasoningEndpointBackpressure:
    """Tests for backpressure handling"""
    
    @patch('src.api.routes.reasoning.database.get_session')
    @patch('src.api.routes.reasoning.get_user_from_context')
    @patch('src.api.routes.reasoning.MockReasoningOrchestrator')
    @patch('asyncio.sleep')
    def test_backpressure_handling(self, mock_sleep, mock_orch, mock_get_user, mock_get_db):
        """Test that backpressure is handled when buffer is full"""
        mock_db = MagicMock()
        mock_get_db.return_value = iter([mock_db])
        mock_get_user.return_value = {"user_id": 1, "role": "admin"}
        
        mock_orch_instance = AsyncMock()
        # Generate many events to trigger backpressure
        async def mock_reason(*args, **kwargs):
            for i in range(150):  # More than max_buffer (100)
                yield {"type": "thinking", "content": f"Thinking {i}", "step_number": i}
            yield {"type": "done", "step_number": 150}
        mock_orch_instance.reason.return_value = mock_reason()
        mock_orch.return_value = mock_orch_instance
        
        client = TestClient(app)
        token = create_admin_token(user_id=1, username="admin")
        response = client.post(
            "/api/v1/reasoning",
            json={"query": "test"},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        # Note: asyncio.sleep is mocked, so we can't verify it was called in TestClient
        # But the code path should be executed

